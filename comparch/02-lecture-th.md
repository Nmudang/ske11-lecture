# Computer Organization Lecture 2 - 3 กันยายน 2014

- สถาปัตยกรรม Von Neumann:
  - นาย Von Neumann ได้กล่าวถึงคอขวดในระบบคอมพิวเตอร์ที่เกิดขึ้นระหว่าง CPU และหน่วยความจำ เนื่องจาก CPU สามารถคำนวณได้อย่างรวดเร็วมาก แต่หน่วยความจำกลับเก็บข้อมูลได้ช้ากว่า
- ในสถาปัตยกรรม Von Neumann จะแบ่ง CPU ออกเป็นสองส่วน ได้แก่
  - **ส่วนควบคุม** (Control)
  - **เส้นทางข้อมูล** (Data path) - ประกอบด้วย ALU (Arithmetic Logic Unit -- หน่วยตรรกะทางคณิตศาสตร์) และรีจิสเตอร์ (ที่พักข้อมูลที่ใช้คำนวณ)
- การทำงานของส่วนควบคุม:
  1. **รับคำสั่ง** (Fetch): รับคำสั่งจากหน่วยความจำ (เช่น แรม) ฉะนั้นแล้วแรมจะเก็บทั้งโค้ดโปรแกรมและข้อมูล คำสั่งที่ได้จะถูกเก็บไว้ใน IR (Instruction Register ซึ่งเป็นที่เก็บข้อมูลพิเศษสำหรับเก็บคำสั่งไว้ใน CPU)
  2. **ถอดรหัส** (Decode): จำแนกชนิดคำสั่งที่ได้รับมา
  3. **ปฏิบัติ** (Exec): ส่งสัญญาณไปยังส่วนที่เกี่ยวข้องให้ทำงานตามคำสั่งที่ได้รับ
- ตัวอย่างเช่น ถ้าได้รับคำสั่ง `ADD` ส่วนควบคุมจะส่งสัญญาณให้ ALU ทำการบวก
- มีคำสั่งอยู่สองประเภท 2:
  1. ควบคุมคำสั่งของ CPU
  2. ควบคุมแหล่งที่มาของข้อมูล
- หน้าที่ของส่วนควบคุม:
  - รับคำสั่งจากหน่วยความจำ
  - ส่งสัญญาณไปยังส่วนต่างๆ
  - ควบคุมการทำงานของโปรแกรมด้วยคำสั่ง `JUMP` และ `BRANCH`
- Datapath ประกอบด้วย:
  - ส่วนปฏิบัติงาน: หน่วยที่ทำงานต่างๆ เช่น ALU, Register file (หน่วยเก็บข้อมูล)
  - การเชื่อมต่อ: เชื่อมต่อไปยังแหล่งข้อมูลต่างๆ

## RISC

RISC ย่อมาจาก Reduced Instruction Set Computer คอมพิวเตอร์ที่มีชุดคำสั่งลดลง

- มีความยาวของคำสั่งคงที่ (32 บิต)
- มีวิธีเข้าถึงหน่วยความจำจำกัด

ข้อจำกัดเหล่านี้มีไว้เพื่อให้ฮาร์ดแวร์เล็กและเรียบง่าย เพื่อที่จะทำงานได้อย่างรวดเร็ว

## สถาปัตยกรรมชุดคำสั่ง MIPS R3000 (ISA)

- ประเภทของคำสั่ง
  - **คำนวณ** - เกี่ยวกับ ALU เช่น `ADD` `SUB` `MUL`
  - **โหลด/เก็บ** - เกี่ยวกับหน่วยความจำ
  - **กระโดด และแตกกิ่ง** - กระโดด (Jump) คือให้ไปที่ตำแหน่งที่ระบุ ส่วนแตกกิ่ง (Branch) คือการกระโดดไปยังตำแหน่งที่ระบุอย่างมีเงื่อนไข
- รูปแบบของชุดคำสั่งมีขนาด 32 บิต
  - **R format:** `OP rs rt rd sa funct`
  - **I format:** `OP rs rt immediate`
  - **J format:** `OP jumptarget`

## การแปลงเลขฐานสอง

	1	1	1	1
	2^3	2^2	2^1	2^0
	8 +	4 +	2 +	1 = 15
	or 2^4 - 1

	1	1	1	1		1	1	1	1
	2^7	2^6	2^5	2^4		2^3	2^2	2^1	2^0
	128+64+	32+	16+		8 +	4 +	2 +	1	= 255
	or 2^8 - 1

สามารถอ่านค่าจากฐาน 2 เป็นฐาน 16 ได้โดยจัดกลุ่มละ 4 แล้วอ่านรวมแต่ละชุด

	1	1	1	1		1	1	1	1
	---sum=15----		----sum=15---
		F					F

เราเรียกตัวเลขที่มีค่านัยสำคัญมากที่สุด (เลขซ้ายสุด) ว่า MSB - Most Significant Bit และเลขที่มีค่านัยสำคัญน้อยที่สุด (เลขขวาสุด) ว่า LSB - Least Significant Bit

## คำสั่งทางคณิตศาสตร์ของ MIPS

```nasm
add $t0, $s1, $s2
sub $t0, $s1, $s2
```

(ให้บวก/ลบค่าใน $s1 และ $s2 แล้วบันทึกไปยัง $t0)

คำสั่งทางคณิตศาสตร์แต่ละตัวจะทำแค่เครื่องหมายเดียวเท่านั้น สัญลักษณ์ `$` มีไว้เพื่อบอกว่าตำแหน่งนั้นอยู่ใน register file

## คำสั่งบวกในภาษาเครื่อง

เทียบคำสั่งบวกกับ R format ซึ่งใช้ในกระบวนการทางคณิตศาสตร์

- **op:** `add`
- **rs:** `$s1`
- **rt:** `$s2`
- **rd:** `$t0`
- **shamt**
- **funct:** `add`

- **op** มีขนาด 6 บิตไว้ระบุคำสั่ง - *op*eration
- **rs** มีขนาด 5 บิตไว้ระบุตำแหน่งในรีจิสเตอร์ของตัวเลขตัวแรก - *r*egister file address of the first *s*ource operand
- **rt** มีขนาด 5 บิตไว้ระบุตำแหน่งในรีจิสเตอร์ของตัวเลขตัวที่สอง - *r*egister file address of the second source operand
- **rd** มีขนาด 5 บิตไว้ระบุตำแหน่งรีจิสเตอร์ที่ไว้เก็บผลลัพท์ - *r*egister file address of the result's *d*estination
- **shamt** มีขนาด 5 บิตสำหรับระบุปริมาณที่ต้องการเลื่อน *sh*ift *am*oun*t* (สำหรับคำสั่ง shift)
- **funct** มีขนาด 6 บิตสำหรับระบุฟังก์ชั่นที่ทำงานกับ opcode นั้น - *funct*ion code augmenting the opcode

## MIPS Register file

- มีรีจิสเตอร์ขนาด 32 บิตจำนวน 32 ตัว
- อยู่ภายใน ALU
- มีพอร์ทเขียน 1 พอร์ต และพอร์ตอ่าน 2 พอร์ต
- พอร์ตรับข้อมูลเข้า: `src1 addr`, `src2 addr`, `dst addr` (ทั้งหมดขนาด 5 บิต), `write data` (ขนาด 32 บิต), `write control` (ขนาด 1 บิต)
- พอร์สสำหรับส่งออกข้อมูล: `src1 data`, `src2 data` (ทั้งหมดขนาด 32 บิต)
- มีสัญญาณ `write control` หนึ่งบิต
  - ถ้า `write control` เปิด ข้อมูลที่ส่งเข้ามาทางพอร์ต `write data` จะถูกเขียนลงในตำแหน่งที่ระบุมาทางพอร์ต `dst addr`
  - ถ้า `write control` ปิด ข้อมูลที่ส่งเข้ามาทางพอร์ต `src1 addr` และ `src2 addr` จะถูกส่งไปยังพอร์ต `src1 data` และ `src2 data`

- คุณสมบัติของรีจิสเตอร์
  - ไวกว่าหน่วยความจำ (รีจิสเตอร์ที่มีขนาดใหญ่กว่าจะทำงานช้ากว่ารีจิสเตอร์ขนาดเล็กกว่า)
  - คอมไพเลอร์ทำงานได้สะดวกกว่า
  - เรียกง่ายกว่าตำแหน่งในหน่วยความจำ

## คำสั่งเข้าถึงหน่วยความจำของ MIPS

**คำสั่งโหลด**

`lw $t0, 4($s3)`

โหลด word มาจากตำแหน่งที่ (ค่าของรีจิสเตอร์ `$s3` + `4`) ไปยังรีจิสเตอร์ `$t0`

**คำสั่งบันทึก**

`sw $t0, 8($s3)`

บันทึกค่าใน `$t0` ไปยังหน่วยความจำตำแหน่งที่ (ค่าของรีจิสเตอร์ `$s3` + `8`)

- ตำแหน่งของหน่วยความจำมีขนาด 32 บิต มาจากค่าของรีจิสเตอร์ฐาน บวกกับค่า offset ซึ่งสามารถเป็นได้ทั้งบวกและลบ
  - offset ขนาด 16 บิต ทำให้สามารถเข้าถึงตำแหน่งได้ไม่เกิน +-2^12 words (+-2^15 bytes) จากค่าของรีจิสเตอร์ฐาน

ตัวอย่างเช่น:

- รีจิสเตอร์ฐาน `$s3` มีค่า 1000
- `4($s3)` หมายความว่าให้เข้าถึงตำแหน่งที่ 1000 + 4 = 1004
- ในการเขียนลูปอาจจะกลับข้างกันใช้ `1000($s3)` แล้วเลื่อน `$s3` ในแต่ละลูปไปทีละ 4 เพื่อเข้าถึงตำแหน่งที่ 1000, 1004, 1008, ...

คำสั่งนี้ใช้รูปแบบ **I format**

- **op**: `lw`
- **rs**: `$s2`
- **rt**: `$t0`
- **16-bit offset**: 4

## คำสั่งเงื่อนไข

- `bne $s0, $s1, Lbl`: Go to `Lbl` if `$s0` != `$s1`
- `beq $s0, $s1, Lbl`: Go to `Lbl` if `$s0` == `$s1`

ตัวอย่างเช่น

```java
if(i == j){
	h = i+j;
}
```

เทียบเท่ากับ

```nasm
		bne $s0, $s1, Lbl1
		add $s3, $s0, $s1 # $s3 = $s0+$s1
Lbl1:	...
```

คำสั่งนี้ใช้รูปแบบ **I format**

- **op**: `bne`/`beq`
- **rs**: `$s0`
- **rt**: `$s1`
- **16 bit offset**: ตำแหน่งระหว่าง `Lbl` กับคำสั่งถัดไป

ที่ใช้ offset เทียบกับคำสั่งถัดไปจาก `bne`/`beq` ก็เพราะว่าเมื่อมีการอ่านคำสั่งมาแล้ว ตัวรีจิสเตอร์ที่เก็บ instruction address จะเลื่อนไปยังตำแหน่งถัดไปโดยอัตโนมัติ

และเนื่องจาก offset นั้นมีขนาด 16 บิตจึงสามารถกระโดดไปได้ไม่เกิน +- 2^15-1 คำสั่งจากคำสั่งถัดไป